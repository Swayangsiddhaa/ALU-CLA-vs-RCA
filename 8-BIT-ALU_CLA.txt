CODE :-  

// CLA
module cla (  
    input  [7:0] A, B,  
    input  Cin,  
    output [7:0] ASID,  
    output Cout  
);  
    wire [7:0] G, P, C;  
  
    assign G = A & B;          
    assign P = A ^ B;         
  
    assign C[0] = Cin;  
    assign C[1] = G[0] | (P[0] & C[0]);  
    assign C[2] = G[1] | (P[1] & C[1]);  
    assign C[3] = G[2] | (P[2] & C[2]);  
    assign C[4] = G[3] | (P[3] & C[3]);  
    assign C[5] = G[4] | (P[4] & C[4]);  
    assign C[6] = G[5] | (P[5] & C[5]);  
    assign C[7] = G[6] | (P[6] & C[6]);  
    assign Cout = G[7] | (P[7] & C[7]);  
  
    assign ASID = P ^ C;  
endmodule  
  

// Logical UNIT
module logic (  
    input  [7:0] A, B,  
    output [7:0] AND, OR, XOR, NAND, NOT, XNOR, NOR  
);  
    assign AND  = A & B;  
    assign OR  = A | B;  
    assign XOR  = A ^ B;  
    assign NAND = ~(A & B);  
    assign NOT  = ~A;               
    assign XNOR = ~(A ^ B);  
    assign NOR  = ~(A | B);  
endmodule  
  

// B Selection using 4:1 MUX
module B_selection (  
    input  [7:0] B,  
    input  [1:0] Bsel,     
    output reg [7:0] Bout,  
    output reg Cin  
);  
    always @(*) begin  
        case (Bsel)  
            2'b00: begin Bout = B;            Cin = 0; end   // ADD  
            2'b01: begin Bout = ~B;           Cin = 1; end   // SUB  
            2'b10: begin Bout = 8'b00000000;  Cin = 1; end   // INC  
            2'b11: begin Bout = 8'b11111111;  Cin = 0; end   // DEC  
        endcase  
    end  
endmodule  
  

// Final 8-bit ALU Using CLA(TOP MODULE)
module alu_8bit (  
    input  [7:0] A, B,  
    input  [2:0] S,        
    input  [1:0] Bsel,    
    output reg [7:0] Y,  
    output Cout  
);  
    wire [7:0] Bout, ASID;  
    wire Cin;  
    wire [7:0] AND, OR, XOR, NAND, NOT, XNOR, NOR;  
  
    // B-Selection using 4:1 mux  
    B_selection bsel (.B(B), .Bsel(Bsel), .Bout(Bout), .Cin(Cin));  
  
    // Arithmetic operation  
    cla add (.A(A), .B(Bout), .Cin(Cin), .ASID(ASID), .Cout(Cout));  
  
    // Logical operation
    logic lu (.A(A), .B(B), .AND(AND), .OR(OR), .XOR(XOR),  
                   .NAND(NAND), .NOT(NOT), .XNOR(XNOR), .NOR(NOR));  
  
    // Final Output Selection using 8:1 mux  
    always @(*) begin  
        case (S)  
            3'b000: Y = ASID;        
            3'b001: Y = AND;  
            3'b010: Y = OR;  
            3'b011: Y = XOR;  
            3'b100: Y = NAND;  
            3'b101: Y = NOT;  
            3'b110: Y = XNOR;  
            3'b111: Y = NOR;  
            default: Y = 8'b00000000;  
        endcase  
    end  
endmodule





//TEST BENCH :- 

`timescale 1ns/1ps

module alu_8bit_tb;

    reg  [7:0] A, B;
    reg  [2:0] S;        // Final select (8:1 MUX)
    reg  [1:0] Bsel;     // Arithmetic B-select (4:1 MUX)
    wire [7:0] Y;
    wire Cout;

    // Instantiate ALU
    alu_8bit uut (
        .A(A),
        .B(B),
        .S(S),
        .Bsel(Bsel),
        .Y(Y),
        .Cout(Cout)
    );

    initial begin
        // Monitor values
        $monitor("Time=%0t | A=%b | B=%b | S=%b | Bsel=%b | Y=%b | Cout=%b",
                $time, A, B, S, Bsel, Y, Cout);

        // -------------------------
        // Test Arithmetic Operations
        // -------------------------

        // ADD (A + B)
        A = 8'b00001010; B = 8'b00000101;  // 10 + 5 = 15
        Bsel = 2'b00;  // B normal
        S = 3'b000;    // choose arithmetic
        #10;

        // SUB (A - B)
        A = 8'b00001100; B = 8'b00000011;  // 12 - 3 = 9
        Bsel = 2'b01;  // B inverted, Cin=1
        S = 3'b000;
        #10;

        // INC (A + 1)
        A = 8'b00001111; B = 8'bxxxxxxxx;  // B is ignored
        Bsel = 2'b10;  // INC
        S = 3'b000;
        #10;

        // DEC (A - 1)
        A = 8'b00101000; B = 8'bxxxxxxxx;
        Bsel = 2'b11;  // DEC
        S = 3'b000;
        #10;

        // -------------------------
        // Test Logic Operations
        // -------------------------

        // AND
        A = 8'b10101010; B = 8'b11001100;
        S = 3'b001;  // AND
        Bsel = 2'b00; // doesn't matter for logic
        #10;

        // OR
        S = 3'b010;
        #10;

        // XOR
        S = 3'b011;
        #10;

        // NAND
        S = 3'b100;
        #10;

        // NOT
        S = 3'b101;
        #10;

        // XNOR
        S = 3'b110;
        #10;

        // NOR
        S = 3'b111;
        #10;

        // End simulation
        $finish;
    end

endmodule


CONSTRAINTS:- 

###############################################################
# XDC Constraints for 8-bit ALU (CLA or RCA)
# Enables Timing Analysis for Pure Combinational Designs
###############################################################

# Virtual Clock - Adjusted period to 14.0 ns (approx. 71.4 MHz) to fix the -3.088 ns WNS violation.
# Original period was 10.0 ns.
create_clock -name virt_clk -period 14.0

# Input Delays - Reduced from 2 ns to 1 ns for slightly more slack (optional change).
set_input_delay 1 -clock virt_clk [get_ports {A[*]}]
set_input_delay 1 -clock virt_clk [get_ports {B[*]}]
set_input_delay 1 -clock virt_clk [get_ports {S[*]}]
set_input_delay 1 -clock virt_clk [get_ports {Bsel[*]}]

# Output Delays - Reduced from 2 ns to 1 ns for slightly more slack (optional change).
set_output_delay 1 -clock virt_clk [get_ports {Y[*]}]
set_output_delay 1 -clock virt_clk [get_ports {Cout}]

# MANDATORY: Allow pure combinational paths to be analyzed.
# This is necessary because there are no flip-flops to automatically define the start/end points of the paths.
set_property ALLOW_COMBINATORIAL_LOOPS TRUE [current_design]
