CODE :-

// =====================================================
// 1. Full Adder (1-bit)
// =====================================================
module full_adder (
    input A, B, Cin,
    output Sum, Cout
);
    assign Sum  = A ^ B ^ Cin;
    assign Cout = (A & B) | (A & Cin) | (B & Cin);
endmodule


// =====================================================
// 2. 8-bit Ripple Carry Adder (RCA)
// =====================================================
module rca_8bit (
    input  [7:0] A, B,
    input  Cin,
    output [7:0] Sum,
    output Cout
);
    wire [7:0] C;

    full_adder fa0 (A[0], B[0], Cin,     Sum[0], C[0]);
    full_adder fa1 (A[1], B[1], C[0],    Sum[1], C[1]);
    full_adder fa2 (A[2], B[2], C[1],    Sum[2], C[2]);
    full_adder fa3 (A[3], B[3], C[2],    Sum[3], C[3]);
    full_adder fa4 (A[4], B[4], C[3],    Sum[4], C[4]);
    full_adder fa5 (A[5], B[5], C[4],    Sum[5], C[5]);
    full_adder fa6 (A[6], B[6], C[5],    Sum[6], C[6]);
    full_adder fa7 (A[7], B[7], C[6],    Sum[7], Cout);

endmodule


// =====================================================
// 3. Logic Unit (7 operations)
// =====================================================
module logic_unit (
    input  [7:0] A, B,
    output [7:0] AND_op, OR_op, XOR_op, NAND_op, NOT_op, XNOR_op, NOR_op
);
    assign AND_op  = A & B;
    assign OR_op   = A | B;
    assign XOR_op  = A ^ B;
    assign NAND_op = ~(A & B);
    assign NOT_op  = ~A;
    assign XNOR_op = ~(A ^ B);
    assign NOR_op  = ~(A | B);
endmodule


// =====================================================
// 4. B Selection Unit (4:1 MUX)
// =====================================================
module B_selection (
    input  [7:0] B,
    input  [1:0] Bsel,
    output reg [7:0] Bout,
    output reg Cin
);
    always @(*) begin
        case (Bsel)
            2'b00: begin Bout = B;           Cin = 0; end  // ADD
            2'b01: begin Bout = ~B;          Cin = 1; end  // SUB (A + ~B + 1)
            2'b10: begin Bout = 8'b00000000; Cin = 1; end  // INC (A + 1)
            2'b11: begin Bout = 8'b11111111; Cin = 0; end  // DEC (A + 255)
        endcase
    end
endmodule


// =====================================================
// 5. Final 8-bit ALU Using RCA(TOP MODULE)
// =====================================================
module alu_8bit_rca (
    input  [7:0] A, B,
    input  [2:0] S,        // operation select for output MUX
    input  [1:0] Bsel,     // arithmetic B selection
    output reg [7:0] Y,
    output Cout
);
    wire [7:0] Bout;
    wire Cin;
    wire [7:0] Sum;
    wire [7:0] AND_op, OR_op, XOR_op, NAND_op, NOT_op, XNOR_op, NOR_op;

    // B preprocessing
    B_selection bs (.B(B), .Bsel(Bsel), .Bout(Bout), .Cin(Cin));

    // Ripple Carry Adder
    rca_8bit rca (.A(A), .B(Bout), .Cin(Cin), .Sum(Sum), .Cout(Cout));

    // Logic unit
    logic_unit lu (
        .A(A), .B(B),
        .AND_op(AND_op), .OR_op(OR_op), .XOR_op(XOR_op),
        .NAND_op(NAND_op), .NOT_op(NOT_op), .XNOR_op(XNOR_op), .NOR_op(NOR_op)
    );

    // Final Output Selection (8:1 MUX)
    always @(*) begin
        case (S)
            3'b000: Y = Sum;       // Arithmetic result
            3'b001: Y = AND_op;
            3'b010: Y = OR_op;
            3'b011: Y = XOR_op;
            3'b100: Y = NAND_op;
            3'b101: Y = NOT_op;
            3'b110: Y = XNOR_op;
            3'b111: Y = NOR_op;
            default: Y = 8'b00000000;
        endcase
    end

endmodule


TEST BENCH:-

module alu_8bit_rca_tb;

    reg  [7:0] A, B;
    reg  [2:0] S;        // Select lines for final output MUX
    reg  [1:0] Bsel;     // B-selection for arithmetic operations
    wire [7:0] Y;
    wire Cout;

    // Instantiate RCA ALU
    alu_8bit_rca uut (
        .A(A),
        .B(B),
        .S(S),
        .Bsel(Bsel),
        .Y(Y),
        .Cout(Cout)
    );

    initial begin
        // Print signals continuously
        $monitor("Time=%0t | A=%b | B=%b | S=%b | Bsel=%b | Y=%b | Cout=%b",
                 $time, A, B, S, Bsel, Y, Cout);

        // -------------------------
        // Arithmetic Tests
        // -------------------------

        // ADD (10 + 5)
        A = 8'b00001010; B = 8'b00000101;
        Bsel = 2'b00;   // ADD
        S = 3'b000;     // Arithmetic select
        #10;

        // SUB (12 - 3)
        A = 8'b00001100; B = 8'b00000011;
        Bsel = 2'b01;   // SUB (= A + ~B + 1)
        S = 3'b000;
        #10;

        // INC (15 + 1)
        A = 8'b00001111; B = 8'bxxxxxxxx;  // B ignored
        Bsel = 2'b10;   // INC
        S = 3'b000;
        #10;

        // DEC (40 - 1)
        A = 8'b00101000; B = 8'bxxxxxxxx;  
        Bsel = 2'b11;   // DEC
        S = 3'b000;
        #10;

        // -------------------------
        // Logic Operation Tests
        // -------------------------

        A = 8'b10101010; 
        B = 8'b11001100;
        Bsel = 2'b00;    // Doesn't matter for logic

        // AND
        S = 3'b001;
        #10;

        // OR
        S = 3'b010;
        #10;

        // XOR
        S = 3'b011;
        #10;

        // NAND
        S = 3'b100;
        #10;

        // NOT
        S = 3'b101;
        #10;

        // XNOR
        S = 3'b110;
        #10;

        // NOR
        S = 3'b111;
        #10;

        $finish;
    end

endmodule

CONSTRAINTS:-

###############################################################
# XDC Constraints for 8-bit ALU (RCA)
###############################################################

# Virtual Clock - Using 14.0 ns (approx. 71.4 MHz) to fix the WNS violation.
create_clock -name virt_clk -period 14.0

# Input Delays - Using 1 ns as a slight buffer.
set_input_delay 1 -clock virt_clk [get_ports {A[*]}]
set_input_delay 1 -clock virt_clk [get_ports {B[*]}]
set_input_delay 1 -clock virt_clk [get_ports {S[*]}]
set_input_delay 1 -clock virt_clk [get_ports {Bsel[*]}]

# Output Delays - Using 1 ns as a slight buffer.
set_output_delay 1 -clock virt_clk [get_ports {Y[*]}]
set_output_delay 1 -clock virt_clk [get_ports {Cout}]

# MANDATORY: Allow pure combinational paths to be analyzed.
set_property ALLOW_COMBINATORIAL_LOOPS TRUE [current_design]